= DTrace DIF Simulator

This tool simulates the execution of DTrace DIF instructions as specified in
https://github.com/cadets/dif-pseudocode[a pseudocode format].
Given an <<State description,initial state>> and a <<Textual DIF,DIF "script">>,
these instructions can be simulated to produce a final system state.
Intermediate states (e.g., register values) can also be inspected.


== Printer

The `dprint` script can be used to output DIF instruction pseudocode or to
interpret streams of DIF instructions ("what does that third operand mean?").

[source, python]
----
# dprint pseudocode LDGS
#
# LDGS: encoding W
#
def ldgs(state, imm, rd):
    state.registers[rd] = state.variables.globals[imm]

# dprint pseudocode --all -o all_instructions
Writing to 'all_instructions': CMP LDGS LDUB MOV SETX

# dprint script script.difi
     1  #
     2  # An example of a simple DTrace instruction stream
     3  #
     4
     5  MOV 0 0 1       # Encoding 'R': rs1=0, rs2=0,  rd=1
     6  SETX 2 0        # Encoding 'Index':  rd=2, index=0
     7  CMP 1 2 0       # Encoding 'R': rs1=1, rs2=2,  rd=0
----



== Simulator

Run the `dsim` script with
optional arguments for <<State description,input/output states>>
and a mandatory <<Textual DIF,DIF "script">> argument.
For example, running the script:

[source, shell]
----
MOV 0 0 1
SETX 2 0
CMP 1 2 0
----

with an initial state containing an integer table `[3,1,2]` yields the
following simulated execution:

[source, terminal]
----
# dsim -i initial-state.yaml script.difi
Loaded initial state:
{'integers': [3, 1, 2]}

Starting simulation in state:
Registers:
  r0:  0x0000000000000000
  r1:  undefined
  r2:  undefined
  r3:  undefined
  r4:  undefined
  r5:  undefined
  r6:  undefined
  r7:  undefined
MOV rs1=0, rs2=0, rd=1
Registers:
  r0:  0x0000000000000000
  r1:  0x0000000000000000
  r2:  undefined
  r3:  undefined
  r4:  undefined
  r5:  undefined
  r6:  undefined
  r7:  undefined
SETX rd=2, index=0
Registers:
  r0:  0x0000000000000000
  r1:  0x0000000000000000
  r2:  0x0000000000000003
  r3:  undefined
  r4:  undefined
  r5:  undefined
  r6:  undefined
  r7:  undefined
CMP rs1=1, rs2=2, rd=0
Registers:
  r0:  0x0000000000000000
  r1:  0x0000000000000000
  r2:  0x0000000000000003
  r3:  undefined
  r4:  undefined
  r5:  undefined
  r6:  undefined
  r7:  undefined

Final simulation state:
{'integers': [0, 1, 2], 'memory': {}, 'registers': {1: 0, 2: 3}, 'strings': []}
----


== State description

The state of the DTrace virtual machine can be specified as a YAML file
containing up to four top-level keys:

`integers`::
  An array of static integer values as generated by DTrace's D compiler.
  DIF has no immediate integer operands for arithmetic instructions,
  so DTrace supplies a static integer table that can be accessed in much
  the same way as a string table in a more conventional system.

`memory`::
  Undefined (TODO)

`registers`::
  A mapping of register numbers to integer values.
  Registers that do not appear in the mapping have undefined values.

`strings`::
  Undefined (TODO)


== Textual DIF

DIF instrutions are exposed to this simulator as textual transliterations of
their binary encodings.
For example, the following is a simple DIF stream that zeroes out registers
`r1` and `r2`:

[source]
----
#
# An example of a simple DTrace instruction stream
#
MOV 0 0 1
MOV 0 0 2
----

Note that, although a `MOV` instruction only has two logical operands (`rs` and
`rd`), the binary DIF encoding for `MOV` has three operands:
`rs1`, `rs2` -- which must be set to 0 -- and `rd`.
Our textual DIF encoding can express anything can be expressed in DIF's binary
encoding, even if it is semantically invalid.
This is useful for exploring corner cases of DIF semantics.
